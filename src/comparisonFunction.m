function [aveTimeScores,perJobsAssigned, avePerUsedThreads,aveCorePer,aveResourceScores] = ...
    comparisonFunction(coreAvailabilityMatrix,speedMatrix,maxNumCoresMatrix)
%Comparison between methods 
if nargin == 0
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Create inputs to algorithm
    % The nth row is the nth computer's list of number of cores of each type that are available.
    % The number of rows should be the number of computers.
    % The number of columns should be the number of types of cores.
    coreAvailabilityMatrix = [
        8,      7,      6,     ;...
        1,      23,     3,     ;...
        14,     8,      2,     ;...
        23,     12,     18,    ;...
        5,      25,     13,    ;...
    ];
    % The nth row is the nth job's list of speed ratios for the each core type.
    % The number of rows should be the number of jobs.
    % The number of columns should be the number of types of cores.
    speedMatrix = [
        30,     41,     22,    ;...
        12,     13,     3,     ;...
        1,      28,     42,    ;...
        20,     22,     6,     ;...
        25,     2,      66,    ;...
        40,     41,     62,    ;...
        42,     13,     6,     ;...
        4,      38,     62,    ;...
        40,     32,     2,     ;...
        45,     3,      26,    ;...
        40,     31,     22,    ;...
        52,     33,     2,     ;...
        5,      38,     42,    ;...
        50,     32,     1,     ;...
        55,     2,      16,    ;...
    ];

% The nth element is the max number of cores that can be used by job n.
    % The number of columns should be the number of jobs.
maxNumCoresMatrix = [8,20,10,4,1,3,27,14,50,8,40,13,4,18,30];%,58,32,33,41,14,21]
elseif nargin<=1 && nargin > 4
    error('Need exactly 3 arguments (Or no arguments for default values)')
end %if nargin == 0 or ~= 3

%% Run The different algorithms

%Apply for first preference
[resultMatrixSM] = simpleMatching(coreAvailabilityMatrix, ...
    speedMatrix, maxNumCoresMatrix);
[rawTimeScoresSM,percentThreadsUsedSM,adjustedTimeScoresSM] = ...
    speedCalc(resultMatrixSM, coreAvailabilityMatrix, speedMatrix, maxNumCoresMatrix);
[resourceScoresSM,perCoresUsedSM] = resourceCalc(resultMatrixSM,...
    coreAvailabilityMatrix,speedMatrix,maxNumCoresMatrix);

%Deferred Acceptance with quotas = TotalNumberOfJobs/TotalNumberOfComputers
[resultMatrixDA1] = deferredAcceptance(coreAvailabilityMatrix, ...
    speedMatrix, maxNumCoresMatrix);
[rawTimeScoresDA1,percentThreadsUsedDA1,adjustedTimeScoresDA1] = ...
    speedCalc(resultMatrixDA1, coreAvailabilityMatrix, speedMatrix, maxNumCoresMatrix);
[resourceScoresDA1,perCoresUsedDA1] = resourceCalc(resultMatrixDA1,...
    coreAvailabilityMatrix,speedMatrix,maxNumCoresMatrix);

%Deferred Acceptance where matchings are based on the number of cores
%available
[resultMatrixDA2] = deferredAcceptance2(coreAvailabilityMatrix, ...
    speedMatrix, maxNumCoresMatrix);
[rawTimeScoresDA2,percentThreadsUsedDA2,adjustedTimeScoresDA2] = ...
    speedCalc(resultMatrixDA2, coreAvailabilityMatrix, speedMatrix, maxNumCoresMatrix);
[resourceScoresDA2,perCoresUsedDA2] = resourceCalc(resultMatrixDA2,...
    coreAvailabilityMatrix,speedMatrix,maxNumCoresMatrix);

%Deferred Acceptance where each round is looking for a best match
[resultMatrixPA] = proposedAlgorithm(coreAvailabilityMatrix, ...
    speedMatrix, maxNumCoresMatrix);
[rawTimeScoresPA,percentThreadsUsedPA,adjustedTimeScoresPA] = ...
    speedCalc(resultMatrixPA, coreAvailabilityMatrix, speedMatrix, maxNumCoresMatrix);
[resourceScoresPA,perCoresUsedPA] = resourceCalc(resultMatrixPA,...
    coreAvailabilityMatrix,speedMatrix,maxNumCoresMatrix);

%% Compile the results
allThreadPercents = [percentThreadsUsedSM;...
                     percentThreadsUsedDA1;...
                     percentThreadsUsedDA2;...
                     percentThreadsUsedPA];
allRawSpeedScores = [rawTimeScoresSM(2,:);...
                     rawTimeScoresDA1(2,:);...
                     rawTimeScoresDA2(2,:);...
                     rawTimeScoresPA(2,:)];
allAdjSpeedScores = [adjustedTimeScoresSM;...
                     adjustedTimeScoresDA1;...
                     adjustedTimeScoresDA2;...
                     adjustedTimeScoresPA];
allResourceScores = [resourceScoresSM;...
                     resourceScoresDA1;...
                     resourceScoresDA2;...
                     resourceScoresPA];
allCorePercents = [perCoresUsedSM;...
                   perCoresUsedDA1;...
                   perCoresUsedDA2;...
                   perCoresUsedPA];

perJobsAssigned = zeros(4,1);
totalJobs = length(maxNumCoresMatrix);
aveTimeScores = zeros(4,1);
avePerUsedThreads = perJobsAssigned;
aveCorePer = perJobsAssigned;
aveResourceScores = aveTimeScores;

for iLoop = 1:length(perJobsAssigned)
    perJobsAssigned(iLoop) = nnz(allThreadPercents(iLoop,:))/totalJobs;
end

for jLoop = 1:length(aveTimeScores)
    aveTimeScores(jLoop) = mean(nonzeros(allAdjSpeedScores(jLoop,:)));
    
end

for kLoop = 1:length(avePerUsedThreads)
    avePerUsedThreads(kLoop) = mean(nonzeros(allThreadPercents(kLoop,:)));
end


aveCorePer = allCorePercents(:);


for nLoop = 1:length(aveResourceScores)
    aveResourceScores(nLoop) = mean(nonzeros(allResourceScores(nLoop,:)));
end

end %of function
