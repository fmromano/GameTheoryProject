
%% bare_conf.tex
%% V1.3
%% 2007/01/11
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.7 or later) with an IEEE conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_jrnl_compsoc.tex
%%*************************************************************************

% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices can trigger bugs that do  ***
% *** not appear when using other class files.                            ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



% Note that the a4paper option is mainly intended so that authors in
% countries using A4 can easily print to A4 and see how their papers will
% look in print - the typesetting of the document will not typically be
% affected with changes in paper size (but the bottom and side margins will).
% Use the testflow package mentioned above to verify correct handling of
% both paper sizes by the user's LaTeX system.
%
% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
\documentclass[conference]{IEEEtran}
% Add the compsoc option for Computer Society conferences.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
 \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at: 
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found as epslatex.ps or
% epslatex.pdf at: http://www.ctan.org/tex-archive/info/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
\usepackage{algpseudocode}
\usepackage[]{algorithm2e}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/
%\usepackage{booktabs}


\usepackage{mdwmath}
\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
%\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later 
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.





% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )

%Examples of how to insert figures and subsections

% An example of a floating figure using the graphicx package.
% Note that \label must occur AFTER (or within) \caption.
% For figures, \caption should occur after the \includegraphics.
% Note that IEEEtran v1.7 and later has special internal code that
% is designed to preserve the operation of \label within \caption
% even when the captionsoff option is in effect. However, because
% of issues like this, it may be the safest practice to put all your
% \label just after \caption rather than within \caption{}.
%
% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class
% option should be used if it is desired that the figures are to be
% displayed while in draft mode.
%
%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex, 
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
%\caption{Simulation Results}
%\label{fig_sim}
%\end{figure}

% Note that IEEE typically puts floats only at the top, even when this
% results in a large percentage of a column being occupied by floats.


% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfloat command, the
% \label for the overall figure must come after \caption.
% \hfil must be used as a separator to get equal spacing.
% The subfigure.sty package works much the same way, except \subfigure is
% used instead of \subfloat.
%
%\begin{figure*}[!t]
%\centerline{\subfloat[Case I]\includegraphics[width=2.5in]{subfigcase1}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{subfigcase2}%
%\label{fig_second_case}}}
%\caption{Simulation results}
%\label{fig_sim}
%\end{figure*}
%
% Note that often IEEE papers with subfigures do not employ subfigure
% captions (using the optional argument to \subfloat), but instead will
% reference/describe all of them (a), (b), etc., within the main caption.


% An example of a floating table. Note that, for IEEE style tables, the 
% \caption command should come BEFORE the table. Table text will default to
% \footnotesize as IEEE normally uses this smaller font for tables.
% The \label must come after \caption as always.
%
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}

%Example formating
%\hfill mds
%
%\hfill January 11, 2007
%
%\subsection{Subsection Heading Here}
%Subsection text here.
%
%
%\subsubsection{Subsubsection Heading Here}
%Subsubsection text here.

%End of the examples (I wanted them out of the main paper)


% Note that IEEE does not put floats in the very first column - or typically
% anywhere on the first page for that matter. Also, in-text middle ("here")
% positioning is not used. Most IEEE journals/conferences use top floats
% exclusively. Note that, LaTeX2e, unlike IEEE journals/conferences, places
% footnotes above bottom floats. This can be corrected via the \fnbelowfloat
% command of the stfloats package.


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Matching Theory and Virtual Machines}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Kristen Hines}
\IEEEauthorblockA{School of Electrical and\\Computer Engineering\\
Virginia Tech\\
Email: kphines@vt.edu}
\and
\IEEEauthorblockN{Ferdinando Romano}
\IEEEauthorblockA{School of Electrical and\\Computer Engineering\\
Virginia Tech\\
Email: fmromano@vt.edu}}


% Make the title area
\maketitle


%Abstract of the paper.
\begin{abstract}
%\boldmath
The assignment of jobs to separate compute clusters 
can be approached using matching theory. 
The problem is modeled as a modified college admissions
game where each institution has multiple quotas,
each of which is of a specified type.
An algorithm based on multiple iterations of the 
colleged admissions deferred acceptance algorithm is 
proposed.
The algorithm is shown to terminate, result in 
a stable matching, and, under certain common conditions,
approximate an optimal solution.
The proposed algorithm is simulated 
and shown to result in either significant improvement 
or only minor regression compared to other approaches.
\end{abstract}


\section{Introduction}
\label{sec:intro}
Because cloud computing is a cost-effective
and flexible system for handling data and programs,
it facilitates ubiquitous IT services,
ranging from online social networking services to infrastructure
outsources, to be available to a wide variety of people.  
These cloud computing services are packaged in the form of
virtual machines (VMs) through virtualization technology.
This ability enables computing technologies
to be virtualized by emulating processors, main memory, storage,
and networking devices \cite{wen_virtualknotter:_2012}.  
%The final product after this virtualization is the virtual machine.

A primary benefit of VMs
is they can be configured to suit a specific application's
needs, such as application isolation, security requirements,
service level-agreements, and computational performance \cite{dhillon_virtual_2013}.  
These VMs and cloud computing servers
are still housed on powerful physical machines at this point.
When each VM's resources are static, 
sourcing jobs to individual VMs involves optimizing
job-VM matchings to maximize resource utilization and
speed of job completion.  This can happen due to time constraints or other restrictions to the VM
The problem is similar to the assignment of jobs to 
distinct compute clusters present on a campus network
where the clusters cannot exchange resources.

This project focuses on turning a simple VM job assignment
problem into a college admissions game.  The jobs act as applicants,
and the VMs as institutions.  The jobs apply for spots
on the VMs until either there are no more jobs in the 
queue, or there are no more VMs created and availabe for the
users at the time.  
It is assumed that VM creation is a significantly 
involved process such that a user would 
wait for an existing VM to become available
rather than instantiate a new one.
In this paper,
a VM-optimal algorithm will be proposed to provide a solution
that is better for both the VMs and the jobs.  
%More will be stated in section three, Method Description.

The paper proceeds as follows:  Section \ref{sec:background} covers 
background knowledge for matching games.  Section \ref{sec:method}
covers the problem formulation and proposed algorithm. Section
\ref{sec:results} discusses simulation results.  Section \ref{sec:related} 
reviews literature similar to the work of this paper.  
Section \ref{sec:conclusion} concludes the present work  
and Section \ref{sec:future} 
suggests areas of future research.

\section{Background}
\label{sec:background}
A review of the stable marriage problem is presented here 
to help the reader understand the proposed solution.
The stable marriage problem is a one-to-one matching
model used to effectively match two groups of agents
 together, such as men and women for a marriage.  
These agents are two disjoint sets.  Each agent
has a complete, strict, and  transitive preference over other
individuals, which means the agent is not indifferent for any choices.  
In addition to this quality, each agent has a chance
of being unmatched. For demonstration purposes,
the two agent sets are men and women, whose sets are 
\( \emph{W} = \{ {w_1}, {w_2}, \ldots {w_p} \} \) and
\( \emph{M} =\{ {m_1}, {m_2}, \ldots {m_n} \} \), 
where \emph{p} does not have to equal \emph{n}.

Their preferences are arranged and represented as ranked 
ordered lists.  An example of such a list is
\( {p_m}_n ={w_2}, {w_4}, \ldots, \emptyset \),
where \( {w_2} \) is the man's first choice for a partner, 
\( {w_4} \) is the second, and so on.  In this case, the final 
choice represents when the man prefers to be single over 
his possible choices.

\emph{Definition 1}:  An outcome is a matching
 \( \mu \) : \emph{M} \( \times \)  \emph{W} \( \rightarrow \)  \emph{M} \( \times \)  \emph{W} such that
\emph{w} = \( \mu(m) \) if and only if 
\emph{m} = \( \mu(w) \) \( \in W \cup \emptyset \), \( \mu(m) \in M \cup \emptyset \)
for all \emph{m, w}.

This implies that agents from one set are matched to either the agents
of the other set or to the null set.  Agents' preferences over outcomes are
determined only by their own preferences for certain partners.

\emph{Definition 2}:  A matching \( \mu \) is stable if and only if it is individual rational and
not blocked by any pair of agents.

Individual rational and blocking pair are defined as followed.

\emph{Definition 3}:  A matiching set is individual rational to all agents if and only if
there does not exist an agent \emph{i} who prefers being unmatched to being
matched.

\emph{Definition 4}:  A matching \( \mu \) is blocked by a pair of agents \emph{(m,w)} if they
prefer each other to the partner they receive at u.  That is, \emph{w} \(\succ_m \) \( \mu (m) \)
and \emph{m} \(\succ_w \) \( \mu (w) \).  Such a pair is called a blocking set,
where \(\succ \) represents an agent's preference of one individual over another.

This means that as long as a matching is not blocked and a matching set is individual
rational, a matched set will be stable.  Therefore:

\emph{Theorem 1}:  A stable matching pair exists for every marriage market.

This theorem was proposed and proven by Gale and Shapley
through their deferred acceptance algorithm, as demonstrated in \cite{gale_college_1962}.

The college applications game extends the concepts behind stable
marriage.  For a college applications game, the two sets of players are the
institutions and the applicants.  A single institution can be matched to multiple
applicants at one time.

\emph{Theorem 2}:  Every applicant is at least as well off under the assignment
given by the deferred acceptance procedure as he would be under any other
stable arrangement.

The end result is a stable and optimal pairing between
the institutions and the applicants.  This is also proven in \cite{gale_college_1962}.  One 
of the issues with the stable marriage problem and the college admissions problem
is that they are applicant optimal.  In other words, the set of agents being
applied to, such as the women in the earlier example, are not guaranteed
their optimal choices. 
There may exist another stable matching where at least one woman
receives a more preferred matching and no women receive a less preferred matching.
If the men and women switched, and the
women were the ones proposing to the men, then it would be the men who are 
not guaranteed their optimal choices. A better solution
would be one where the results between the applicants
and the institutions were equally optimal.

\section{Method Description}
\label{sec:method}
The problem formulation and proposed algorithm
are described in the following subsections.

\subsection{Problem Formulation}
This paper explores the problem of optimal assignement
of jobs to separate VMs.  Each of these
jobs perform differently on different cores types where these
core types can be graphical processors, computational
processors, or something specifically for a certain program.  
Each of these VMs
have different core types, each job can only be divided into
a finite number of threads, and each job is assigned to 
one VM at a time.

The problem can be modeled as a college admissions
game with a few key differences:
The institutions
have multiple quotas, each applicant can fill multiple
slots of different types, and applicants prefer some
slot types over others.
As before, an applicant cannot be
divided among multiple institutions.

Key assumptions for this problem are:  the VMs
are viewed as flexible computers, jobs are submitted at
the same time, chosen jobs are completed simulatenously,
unchosen jobs are submitted with the next round, no
indifference, and no externalities.

\subsection{Proposed Algorithm}
The proposed algorithm is based on a deferred acceptance
college admissions algorithm with special modifications to optimize it for 
the situation where the institutions have multiple quotas of different
types and the applicants can fill multiple slots.
\subsubsection{Algorithm}

\begin{algorithm}
\caption{Proposed Algorithm}\label{alg:PA}
\KwData{Number of cores per VM available, Speed ratio matrix for jobs, Max threads used per job}
\KwResult{Matrix with jobs matched to VMs}

Initialize preference matrices and quotas\;

\While{Either jobs or VMs are left}{
	1. Perform a one-to-one matching using the Deferred Acceptance Algorithm\;
	2. Determine most important matching\;
	3. Save this match to the results matrix\;
	4. Update preference matrices and core availability matrix\;
}

Compile results and send to user\
\end{algorithm}
\underline{Step 1}: Calculate the preferences of the jobs (applicants) and the VMs
(institutions).
A job's preference for a particular VM is determined simply:
given the processors available on each VM, if a job would peform 
faster on one VM than another, then the first VM is preferred over the second. 
Given the relative speeds of each processor at performing a particular job,
the speed of that job on a particular VM is calculated by first choosing the fastest
available processors until the job's processor limit is reached or there are no more
processors available on the VM.
Then, the speeds of the chosen processors are summed together to give 
the VM's total speed at the job.
A job prefers one VM over another if its total speed
is higher than the other's. 

A VM's preference for a particular job is based on the assumption
that a VM wants to maximize utilization of its resources. 
In this case, a job that can utilize more processors than another
is preferrable. It is assumed that the number of processors that a job can use 
does not depend on the VM or the processor types and so each VM
has the same preference ranking of jobs.


\underline{Step 2}: Perform a one-to-one matching.
The jobs are matched to the VMs according the calculated preferences
using a college admissions algorithm where the quota of a VM is 
set to 1 if it has at least 1 processor still available. 
Otherwise, its quota is set to 0.

\underline{Step 3}: Determine the most important matching.
A job that can use the greatest number of processors is the
most highly preferred and so it is matched to its first choice
of VM. Thus this pair is stable and can be assigned to 
the finalized matching of the algorithm. 
This job and the processors it uses are no longer available
so they are removed from future iterations of the algorithm.

\underline{Step 4}: Return to Step 1.
The algorithm is repeated either until all processors are 
assigned a job or until all jobs are matched 
to a VM.

\subsubsection{Guarantee of Termination}
The algorithm is guaranteed to terminate because there is a 
finite number of jobs and each iteration of the algorithm
matches one job to a VM.

\subsubsection{Stability of Algorithm}
The proposed algorithm produces a stable matching because in
each iteration, the college admissions game is used to find
a set of stable matchings.
Out of the jobs listed in the resultant set of stable matchings,
the job that can use the most processors is preferred most
by every VM. Thus, that job will be matched with its first 
choice and its matching to a VM is a stable matching.
Thus, each pair produced by an iteration of the proposed
algorithm is stable, and therefore the final matching is stable.

\subsubsection{Optimality of Algorithm}
Whether the matching is optimal can be understood in multiple senses.
In this section, three different approaches to optimality are 
discussed as they apply to the proposed algorithm.

\underline{Resource Utilization}:
A simple goal of the proposed algorithm would be to 
maximize processor utiliztion so that no computing 
resources go unused/wasted.

The proposed algorithm does not always maximize processor 
utilization. However, it does in every iteration 
where the preferred VM of the job with
the greatest possible processor utilization
has at least as many processors 
available as either
    i) that job can use or
    ii) any other VM has.
This situation is common because, often, a //vm with more 
available processor resources will outperform
one with fewer. The exceptions occurs where there is 
a VM that has special purpose processors, such as ones
that are developed for specific tasks.  Those exceptions
will significantly outperform those available at other 
VMs.  This VM does not meet either 
of conditions i) or ii) listed above.

\underline{Total Job Completion Time}:
The total computation time, i.e., the 
sum of total computation times for each job,
is another good measure of the optimality 
of the proposed algorithm.

Assuming individual jobs cannot take advantage
of processors previously used by other jobs
that have completed, 
the proposed algorithm minimizes total 
computation time whenever 
jobs that use more processors are jobs that would take 
longer to complete than any other job. 
By 'take longer to complete', we mean take longer than
other jobs if the other jobs were to use a subset or 
superset of the processors used by the first job.
When this condition is met, the job that takes the
longest is given the greatest speed possible, the job that 
takes the 2nd longest is given the next greatest speed 
possible for it, and so on. 
Thus, total computation time is minimized.

In the proposed algorithm, this condition that jobs use
more processors take longer is not guaranteed.
However, it is strongly encouraged by the 
proportional fairness of the algorithm:
Jobs that would take longer to complete are incentivized
to be able to use more processors.

\underline{Proportional Fairness}:
In the proposed algorithm, jobs' individual computation
times/total required processing are not factored into
the preferences and so have no bearing on the matchings.
Instead, it is the processor utilization ability of 
a job that effects its ranking. This leads to a proportional
fairness in which jobs that are shorter are still given 
a fair amount of processing power so that they will not take
very long. 
On the other hand, jobs that
require more processing power, i.e. would take longer,
are incentivized to be able to use more pocessors than 
jobs that do not take as long.

For a job that would take time to complete 
\(\tau_1 > \tau_2\), where \(\tau_2\) is the
completion time for a second job,
Job 1 would reduce its completion time by an 
absolute amount 
\(\Delta \tau_1 = \tau_1-\frac{\tau_1}{f}\) 
if it could increase its speed by a factor \(f\).
Similarly, for Job 2, 
\(\Delta \tau_2 = \tau_2-\frac{\tau_2}{f}\).
Thus, 
\(\tau_1=\Delta \tau_1(1-\frac{1}{f})\)
and
\(\tau_2=\Delta \tau_2(1-\frac{1}{f})\).
Since 
\(\tau_1 > \tau_2\), we have
\(\frac{\Delta\tau_1}{1-\frac{1}{f}} > \frac{\Delta\tau_2}{1-\frac{1}{f}}\) 
\(\implies \Delta \tau_1 > \Delta \tau_2\).
Therefore, Job 1 has more to gain by increasing its speed by 
a given factor than Job 2 does and so Job 1 has a greater incentive
to be able to use more processors.




\section{Results and Discussion}
\label{sec:results}
The proposed algorithm was compared to three alternative algorithms.  
The first was a simple matching scheme where jobs are matched with their preferred VM.  
This case would be similar to a VM lab where each user applies for a VM without knowing how many others are also applying.
This scheme disregards the availability of resources on the VM, which means some jobs may be matched to the a VM, but then are unable to complete in a reasonable time due to lack of resources.  
This is the scheme to which the other three variations of the deferred acceptance algorithm, including the proposed algorithm, are compared.

The second scheme involves a deferred acceptance routine where the quotas depend on how many jobs are listed and how many VMs are available.  
It takes these two values and divides the jobs among the available VMs.  
This scheme is intended to favor the jobs that are able to be serviced by the VM.  
However, this case faces the same issue as simple matching: there may not be enough resources for all of the matched jobs.  

The third algorithm is another deferred acceptance algorithm variant.  
In each iteration of this scheme, the deferred acceptance algorithm matches a set of jobs to a set of VMs.
This is handled by setting the quotas to one for each iteration until a VM is filled.  
Once a VM is filled, its quota is set to 0, and no more jobs can be matched to that VM.  
Each iteration, the preferences for the VM and the jobs are updated in order to reflect which jobs are matched and what resources are still available.  
This process ends once all of the jobs are matched or all of the VMs are filled.  
This algorithm is expected to be the most fair out of the three because it does not match jobs to a VM that would not able to complete it.
  
Five different metrics characterize the performance of the proposed algorithm compared to the simple matching algorithm
and the two different versions of the deferred acceptance algorithm.  
The metrics are average speed scores, average percent of jobs assigned to each VM, average percent of available threads utilized for a job, 
the average number of cores used per VM, and a resource score that represents how well the jobs could utilize their preferred cores.  
The average speed score is based on the speed ratios for each job depending on the core type.  
For this number, higher scores are better, but they can only be compared within a single simulation.  
To enable comparisons across the different simulations, these values were converted to percent changes.  
The simple matching scheme was set as the baseline, which is why each of its sections for percent change
are zero percent.

The next metric, the average percent of jobs assigned to a VM,
represents the number of jobs successfully assigned to a VM before the available cores were depleted.  
The average percent of available threads utilized for a job represents how efficient each scheme is.  
A job does not need to have all of its threads used to be completed, but the job would be finished faster if more threads were used.  
The average number of cores used per VM represents how effectively the VM resources are used.
In this work, the VMs prefer to be completely utilized. 
This score would also reflect whether a VM is matched to any jobs at all.
Finally, the last score is the resource score, which represents how well the jobs are distributed among the different core types.  
It reflects how frequently each job is executed the best it could be on a given VM. 

These algorithms were compared in three different tests.  
For each test, 
a set of randomly defined inputs were entered into each algorithm 
for each iteration.  
During these iterations, the metrics were sampled, 
averaged, and stored until all of the simulations were finished.  
All random
numbers were generated using the uniform random function in MATLAB.  
The parameters for the inputs of the comparison function for each 
iteration can be found in Table I.

The number of simulations represents how many simulations the comparison 
program executed.  The number of VMs parameter decided the minimum 
and maximum number of VMs, from 1 to a positive integer, during an iteration.  
The number of jobs parameter decided the maximum and minimum number 
of jobs during each iteration.  The number of core types parameter decided 
the minimum and maximum number of different core types that would be 
available for the user.  The maximum number of cores per type parameter 
decided how many of which type of core were available for a job.  
The maximum number of threads per job parameter decided how big the
 job could be and how many threads could be matched to available cores.  
The speed ratios parameter decided how fast each job would be on each core type.

Each algorithms is referred to according to the following
abbreviations:  S.M. refers to the simple matching algorithm. 
D.A. 1 refers to the deferred acceptance algorithm with evenly distributed quotas. 
D.A. 2 refers to the deferred acceptance algorithm which performs a one-to-one 
matching each iteration.  D.A. 2 is the algorithm whose preference matrices change
each iteration due to jobs being matched and cores being used.  
Prop. Alg. refers to the proposed algorithm introduced in this paper.

The test cases represent three possible scenarios:  one where the VMs and 
jobs are evenly matched, one where there are many available VM resources, 
and one where the number of jobs typically outnumbers the number of 
available VMs.  For these cases, the job performance is measured by the percent jobs 
assigned, average available threads used, average resource score, and average 
percent change in the speed score compared to the simple matching scheme.  The 
VM performance is based on the average percent of cores used because its main 
requirement was to have all of the resources among all of the VMs used.  All values 
used for comparisons are defined as percentages.

% Inputs Table
\begin{table}[h]
    \resizebox{.485\textwidth}{!}{%
        \begin{tabular}{l|l|l|l|}
            \cline{2-4}
             & \multicolumn{3}{c|}{Comparison} \\ \cline{2-4} 
              & I & II & III \\ \hline
              \multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}Number of Simulations\end{tabular}} & 500 & 100 & 100 \\ \hline
              \multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}Number of VMs\end{tabular}} & {[}1,20{]} & {[}1,50{]} & {[}1,20{]} \\ \hline
              \multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}Number of Jobs\end{tabular}} & {[}1,50{]} & {[}1,100{]} & {[}1,100{]} \\ \hline
              \multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}Number of Core Types\end{tabular}} & {[}1,5{]} & {[}1,10{]} & {[}1,5{]} \\ \hline
              \multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}Max. Number of Cores per Type\end{tabular}} & {[}1,25{]} & {[}1,50{]} & {[}1,50{]} \\ \hline
              \multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}Max. Number of Threads per Job\end{tabular}} & {[}1,50{]} & {[}1,200{]} & {[}1,50{]} \\ \hline
              \multicolumn{1}{|l|}{Speed Ratios} & {[}1,100{]} & {[}1,200{]} & {[}1,200{]} \\ \hline
          \end{tabular}
      }
      \newline
      \caption{Randomized Inputs to Comparisons}
      \label{inputs}
  \end{table}
% End Inputs Table

% Comparison Table I
\begin{table}[h]
\resizebox{.485\textwidth}{!}{%
    \begin{tabular}{l|l|l|l|l|}
        \cline{2-5}
         & S.M. & D.A. 1 & D.A. 2 & Prop. Alg. \\ \hline
        \multicolumn{1}{|l|}{Avg. Speed Score} & 780 & 722 & 942 & 989 \\ \hline
        \multicolumn{1}{|l|}{Percent Jobs Assigned} & 24.92\% & 41.67\% & 37.1\% & 34.49\% \\ \hline
        \multicolumn{1}{|l|}{Avg. Avail. Threads Used} & 71.41\% & 78.96\% & 65.57\% & 64.83\% \\ \hline
        \multicolumn{1}{|l|}{Avg. Cores Used} & 63.63\% & 87.94\% & 98.57\% & 98.53\% \\ \hline
        \multicolumn{1}{|l|}{Avg. Resources Score} & 54.49\% & 62.41\% & 50.02\% & 49.5\% \\ \hline
        \multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}Avg. Speed Score Change\\ from Simple Matching\end{tabular}} & 0.00\% & -7.496\% & 20.82\% & 26.78\% \\ \hline
    \end{tabular}
    }
    \newline
    \caption{Comparison I}
    \label{compI}
\end{table}
% End Comparison Table I

% Comparison Table II
\begin{table}[h]
    \resizebox{.485\textwidth}{!}{%
        \begin{tabular}{l|l|l|l|l|}
            \cline{2-5}
             & S.M. & D.A. 1 & D.A. 2 & Prop. Alg. \\ \hline
             \multicolumn{1}{|l|}{Avg. Speed Score} & 8668 & 8185 & 10524 & 9161 \\ \hline
             \multicolumn{1}{|l|}{Percent Jobs Assigned} & 57.93\% & 75.15\% & 74.45\% & 74.63\% \\ \hline
             \multicolumn{1}{|l|}{Avg. Avail. Threads Used} & 88.65\% & 85.81\% & 85.00\% & 79.91\% \\ \hline
             \multicolumn{1}{|l|}{Avg. Cores Used} & 72.25\% & 87.51\% & 99.21\% & 86.50\% \\ \hline
             \multicolumn{1}{|l|}{Avg. Resources Score} & 67.09\% & 66.49\% & 61.90\% & 53.64\% \\ \hline
             \multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}Avg. Speed Score Change\\ from Simple Matching\end{tabular}} & 0.00\% & -5.57\% & 21.41\% & 5.69\% \\ \hline
         \end{tabular}
     }
     \newline
     \caption{Comparison II}
     \label{compII}
\end{table}
% End Comparison Table II

% Comparison Table III
\begin{table}[h]
    \resizebox{.485\textwidth}{!}{%
        \begin{tabular}{l|l|l|l|l|}
            \cline{2-5}
             & S.M. & D.A. 1 & D.A. 2 & Prop. Alg. \\ \hline
             \multicolumn{1}{|l|}{Avg. Speed Score} & 2742 & 2541 & 3724 & 3516 \\ \hline
             \multicolumn{1}{|l|}{Percent Jobs Assigned} & 48.12\% & 68.78\% & 57.06\% & 59.73\% \\ \hline
             \multicolumn{1}{|l|}{Avg. Avail. Threads Used} & 89.65\% & 95.17\% & 92.89\% & 84.35\% \\ \hline
             \multicolumn{1}{|l|}{Avg. Cores Used} & 47.48\% & 86.52\% & 89.93\% & 88.44\% \\ \hline
             \multicolumn{1}{|l|}{Avg. Resources Score} & 72.73\% & 80.30\% & 74.21\% & 72.60\% \\ \hline
             \multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}Avg. Speed Score Change\\ \\ from Simple Matching\end{tabular}} & 0.00\% & -7.32\% & 35.79\% & 28.21\% \\ \hline
         \end{tabular}
     }
     \newline
     \caption{Comparison III}
     \label{compIII}
\end{table}
% End Comparison Table III


\subsection{Comparison I:  Normal amount of VMs to jobs}
Table \ref{compI} shows that, in this comparison case, the simple matching performed worse compared to 
the other approaches
on average available threads used, average cores used, and average resource
 score.  
 The first deferred acceptance algorithm performed similarly to simple matching.  
 Both the second deferred acceptance algorithm and the proposed 
algorithm performed similarly to each other and better on average than the other 
two for this example.  
The first deferred acceptance algorithm performed better 
in terms of resources used and threads used for this example.  
The proposed algorithm performed its jobs the fastest.

\subsection{Comparison II: More VM resources compared to jobs}

For this comparison, the second deferred acceptance algorithm does as well as or
better than the other algorithms.  As can be seen in Table \ref{compII} on page
\pageref{compII},
the proposed algorithm and the first deferred
acceptance algorithms performed similarly on most metrics except average resource 
score and average percent change in the speed score.  The proposed algorithm did
better for average percent change in the speed score, but worse for average 
resource score.  The simple matching algorithm performed similarly to the first
deferred acceptance algorithm on everything except percent of jobs assigned.

\subsection{Comparison III: More jobs than VM resources available}

For this case, the second deferred acceptance algorithm performed the best in
 everything except percent jobs assigned and average resource score, as shown
 in Table \ref{compIII} on page \pageref{compIII}.  The first 
deferred acceptance algorithm performed the best in those two categories. 
 The proposed algorithm's results lie between the first and second deferred 
acceptance results.  The simple matching performed worse than the other 
algorithms on average for this case.


\subsection{Discussion of Results}
In all cases, the first deferred acceptance algorithm average resource 
score and percent of jobs assigned was usually the highest or second
 highest compared to the other algorithms.  It was also the slowest at 
job completion compared to the others.  The second deferred acceptance
 algorithm performed generally the best in the rest of the categories, with
 the proposed algorithm measuring close to it.  The simple matching algorithm
 performed normally as well as the first deferred algorithm.  Its main 
weakness was that it normally did not have the resources to service 
many of the available jobs, which would make users very unhappy.

Compared to the other cases, the proposed algorithm did not have a
significant strengths over the other algorithms.  On average, 
it performed better than the simple matching and first deferred 
acceptance algorithm for most of the metrics.  In addition, it was 
normally as good as the second deferred acceptance algorithm. 
 This algorithm was as VM-optimal in terms of cores used as the second 
deferred acceptance algorithm, and more optimal compared to the other 
two algorithms.  As for job-optimal, it was not as good as the first 
deferred acceptance algorithm.  However, the proposed algorithm 
created better matches for jobs than simple matching.



\section{Related Work}
\label{sec:related}
Variations of this work can be found, 
handling a variety of problems in multiple areas of virtualization and cloud computing.  
These problems include topics such as VM co-scheduling, general networking situations where defining utility functions may be difficult, 
VM migration in cloud computing, distributed loads for VMs, and VM shuffling for congestion reduction.  
A few of these examples these works are discussed here.
\cite{jiang_analysis_2008}
\cite{adolphs_distributed_2012}

In \cite{xu_seen_2011}, the authors prepared the background to apply matching theory to networking problems, such as those where utility functions are difficult or impossible to find.
Rather than pursuing optimality, they aimed for stability and developed a possible solution for non-centralized coordination between ISPs in an ISP peering example.  The simplicity that Matching Theory affords, along with privacy benefits, makes this approach interesting.  However, their work is polarized towards the proposing side of the two parties.  

This issue was addressed in their next work \cite{xu_egalitarian_2011} where the authors sought to reduce the polarization issues they had in the previous paper, similar to the approach in this project.  
The problem they examined was server a maintenance scenario, where VM migration is triggered by periodic upgrades, maintenances, and hardware failures.  
They introduce a current match dissatisfaction score, a metric for each agent used to encourage a more egalitarian solution.  
This dissatisfaction score was derived from each agents individual dissatisfaction with its current pair.  
The results showed that the overall dissatisfaction was reduced while maintaining stability.  
The drawback behind this work is that their algorithm performed poorly when the number of quotas of the servers was close to the total number of migrating VMs.

A problem faced in virtualization technology is the limits introduced by the physical machines that host the VMs.  
Dhillon, Purini, and Kashyap \cite{dhillon_virtual_2013} attempt mitigate this performance degradation using matching theory to create a co-scheduling algorithm.  
They defined the degradation issue as a stable roommate problem, 
where the VMs are paired together on a machine based on their compatibility and their likelihood of interfering with each other.  
Their work was then compared with other algorithms that handled co-scheduling and showed that the stable marriage and stable roommates problems provide no improvement over current technology available for co-scheduling.  
However, their work opens the way for approaches based on variants of the stable matching and stable roommates problems.




\section{Conclusion}
\label{sec:conclusion}
Though it does not prove to be a catch-all solution to matching jobs
to VMs,
the proposed algorithm does demonstrate itself to be the 
most advantageous of those considered here when working with situations
similar to Comparison I: there are more jobs than VMs but the number
of cores is limited and the speeds of each core type for a particular
job are more similar.
Even when the situation does not meet these conditions, however, 
the algorithm does not always perform too poorly compared to the best alternative.
So, we can say that using the proposed algorithm is a reasonable 
approach in other scenarios as well. 
The scenarios considered in this work are not exhaustive 
and situations where the parameters are set to other ratios 
are worth consideration.



\section{Future Work}
\label{sec:future}
This paper studies an interesting extension of the college admissions
algorithm where the institutions have multiple quotas of different types
and the applicants can fill any of a particular instution's quotas.
Other, similar modifications to the college admissions algorithm 
may be worthy of interest such as having each applicant only able fill certain 
quota types rather 
simply preferring some types over others.
The proposed algorithm of this paper could also be extended to consider 
scenarios that are complicated by software licensing restrictions
or the need to factor in job length and complexity.
These considerations could lead to more realistic approximations 
so that the algorithm can more practically lend itself to 
real-world implementation.

\section{Individual Contributions}
Kristen Hines formulated the problem, 
and tested the proposed algorithm against other 
approaches which she implemented along with the 
college admissions algorithm to produce the 
results of the project.
She also researched the background literature related to the 
project and contributed to this written report.

Ferdinando Romano formulated the problem,
and developed and implemented the proposed algorithm.
He developed other implementations against which the
proposed algorithm was tested and
he also derived the results about the algorithm's properties 
relating to termination, stability, and optimality
and contributed to this written report.







% use section* for acknowledgement


% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
\bibliography{IEEEabrv,references}{}
\nocite{*}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
%\begin{thebibliography}{}
%\end{thebibliography}




\end{document}


